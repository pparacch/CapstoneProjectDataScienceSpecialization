---
title: "Assignment: Milestone Report (Capstone Project)"
author: "Pier Lorenzo Paracchini"
date: "25 april 2016"
output: 
  html_document: 
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Required Libraries
require(knitr)

# WINDOWS LOCALE SETTING
Sys.setlocale(category = "LC_ALL",locale = "English_United States.1252")

getOption("encoding")
Sys.getlocale("LC_CTYPE")
localeToCharset()
```

# Summary

The main objective of this __MIlestone Report__ is to display and explain only the major features of the data you have identified and briefly summarize your next" plans for creating the prediction algorithm and Shiny app behind the final product. Specifically as stated in the assignment description:

* Demonstrate that the data has been downloaded and loaded
* Create a basic report of summary statistics about the data sets (twitters, news, blogs)
* Report any interesting findings and eventual considerations/ implications 
* Get feedback on the "next" plans for creating a prediction algorithm and Shiny app

# The Data

The data is from a corpus called [HC Corpora](www.corpora.heliohost.org) and it can be downloded at the following [link](https://d396qusza40orc.cloudfront.net/dsscapstone/dataset/Coursera-SwiftKey.zip). The corpora have been collected from publicly available sources by a web crawler and includes tweets, blogs and news in engligh, german, finnish and russian (separated in different set of files for each language).

From the information available at [About the Corpora](http://webcache.googleusercontent.com/search?q=cache:dzpVyq5etNYJ:www.corpora.heliohost.org/aboutcorpus.html+&cd=3&hl=en&ct=clnk&gl=us):

    ' You may still find lines of entirely different languages in the corpus. There are 2 main reasons for that: 1. Similar languages. Some languages are very similar, and the automatic language checker could therefore erroneously accept the foreign language text. 2. "Embedded" foreign languages. While a text may be mainly in the desired language there may be parts of it in another language. Since the text is then split up into individual lines, it is possible to see entire lines written in a foreign language.Whereas number 1 is just an out-and-out error, I think number 2 is actually desirable, as it will give a picture of when foreign language is used within the main language.'

Note! The focus of the analysis is on the __english language only ('en_US')__ - covering: tweets (twitter), news and blogs.

```{r dataLoad, cache = T, echo = F}
con <- file("./../data/original/final/en_US/en_US.twitter.txt", "r") 
data.twitter.all <- readLines(con, skipNul = T)
close(con)

con <- file("./../data/original/final/en_US/en_US.news.txt", "r") 
data.news.all <- readLines(con, skipNul = T)
close(con)

con <- file("./../data/original/final/en_US/en_US.blogs.txt", "r") 
data.blogs.all <- readLines(con, skipNul = T)
close(con)

data.twitter.all.nchar <- nchar(data.twitter.all)
data.news.all.nchar <- nchar(data.news.all)
data.blogs.all.nchar <- nchar(data.blogs.all)


#Some Statistic about the original files
data.sources <- c("twitters", "news", "blogs")
data.noOfLines <- c(length(data.twitter.all), length(data.news.all), length(data.blogs.all))
data.maxNoOfChars <- c(max(data.twitter.all.nchar), max(data.news.all.nchar), max(data.blogs.all.nchar))
data.minNoOfChars <- c(min(data.twitter.all.nchar), min(data.news.all.nchar), min(data.blogs.all.nchar))

data.info.df <- data.frame(sources = data.sources, 
                           noOfLines = data.noOfLines, 
                           maxNoOfChar = data.maxNoOfChars,
                           minNoOfChar = data.minNoOfChars)
```

## Some basic statistics about the Corpora

`r kable(data.info.df)`

Some considerations

* the __amount of data available__ considering the tweets, news and blogs entries. For simplification the __exporation__ has been done using a representative sample to infer facts about a population (considering also limitations connected with the available processing hardware)

* the minimum size, in terms of number of characters, for the different entries. There are tweets, news and blogs with few characters - __are they relevant__?

## Encoding Issues (Gremlings)

When loading the data the following locale/ encoding has been used __`r Sys.getlocale("LC_CTYPE")` \ `r localeToCharset()`__. Inspecting the loaded data it is possible to identify some encoding issues (gremlings) due to the unrecognized characters (not supported languages, emoticons, etc)

    '`r data.twitter.all[15]`'
    '`r data.twitter.all[10967]`'
    '`r data.twitter.all[7046]`'


In order to remove such gremlings the following __strategy__ and __simplification__ has been considered: limit the set of available characters to the __ASCII__ charset, removing non ASCII characters.


```{r removeGremlings, collapse = T, cache=T}
##Using iconv to replace non ASCII char with an empty char
data.twitter.all.ascii <-  iconv(data.twitter.all, from = localeToCharset(), to = "ASCII", "")
data.news.all.ascii <-  iconv(data.news.all, from = localeToCharset(), to = "ASCII", "")
data.blogs.all.ascii <-  iconv(data.blogs.all, from = localeToCharset(), to = "ASCII", "")


##Reset working data after removing Gremlings
data.twitter.all <- data.twitter.all.ascii
data.twitter.all.nchar <- nchar(data.twitter.all)

data.news.all <- data.news.all.ascii
data.news.all.nchar <- nchar(data.news.all)

data.blogs.all <- data.blogs.all.ascii
data.blogs.all.nchar <- nchar(data.blogs.all)
```

    '`r data.twitter.all[15]`'
    '`r data.twitter.all[10967]`'
    '`r data.twitter.all[7046]`'

## Entries with a limited number of chars

### Twitter Corpora

```{r tweetsDistribution, echo = F}
hist(nchar(data.twitter.all), main = "No Of Chars Distribution - Tweets", xlab = "no of characters")

shortTweets.maxNoOfChar <- 20
```

There are around `r sum(data.twitter.all.nchar <= shortTweets.maxNoOfChar)` tweets (`r round(sum(data.twitter.all.nchar <= shortTweets.maxNoOfChar)/ length(data.twitter.all),2)`% ) that are less than `r shortTweets.maxNoOfChar` chars long. Few examples of such tweets can be found below:

```{r tweetsShortAnalysis, collapse=T, echo=F}
#Find tweets that are less than 
twitter.lessThanOr3chars <- data.twitter.all[data.twitter.all.nchar <= shortTweets.maxNoOfChar]
twitter.lessThanOr3chars[100:110]
```

Because of the limited number of such tweets and the "irrelevance" of their content (especially the ones with less than 10 chars), it has been decided to remove them from the __twitter corpora__.

```{r tweetsShortRemoval, collapse=T, echo = F}
#Removing such short tweets
data.twitter.all <- data.twitter.all[data.twitter.all.nchar > 20]
data.twitter.all.nchar <- nchar(data.twitter.all)

#twitter.df <- data.frame(text = data.twitter.all, nchar = data.twitter.all.nchar)
```

### News Corpora

```{r newsDistribution, echo = F}
#Let's focus on news
a <- data.news.all.nchar < 1500
par(mfrow=c(1,2))
hist(nchar(data.news.all[a]), main = "No Of Chars per News (< 1500)", breaks = 100, xlab = "no of characters")
hist(nchar(data.news.all[!a]), main = "No Of Chars per News (>= 1500)", breaks = 100, xlab = "no of characters")

shortNews.maxNoOfChar <- 20
```

There are around `r sum(data.news.all.nchar <= shortNews.maxNoOfChar)` news (`r round(sum(data.news.all.nchar <= shortNews.maxNoOfChar)/ length(data.news.all),2)`% ) that are less than `r shortNews.maxNoOfChar` chars long. Few examples of such news can be found below:

```{r newsShortAnalysis, echo = F}
a <- data.news.all.nchar <= shortNews.maxNoOfChar
head(data.news.all[a], 10)
```

Because of the limited number of such news and the "irrelevance" of their content , it has been decided to remove them from the __news corpora__.

```{r newsShortRemoval, echo = F}
#Removing such short news
data.news.all <- data.news.all[data.news.all.nchar > shortNews.maxNoOfChar]
data.news.all.nchar <- nchar(data.news.all)

#news.df <- data.frame(text = data.news.all, nchar = data.news.all.nchar)
```

### Blogs Corpora

```{r blogsDistribution, echo = F}
a <- data.blogs.all.nchar < 1300
par(mfrow=c(1,2))
hist(nchar(data.blogs.all[a]), main = "No Of Chars per Blogs (< 1300)", xlab = "no of characters")
hist(nchar(data.blogs.all[!a]), main = "No Of Chars per Blogs (>= 1300)", breaks = 10000, xlab = "no of characters")

shortBlogs.maxNoOfChar <- 20
```

There are around `r sum(data.blogs.all.nchar <= shortBlogs.maxNoOfChar)` blogs __(`r round(sum(data.blogs.all.nchar <= shortBlogs.maxNoOfChar)/ length(data.blogs.all),2)`%)__ that are less than __`r shortBlogs.maxNoOfChar` chars__ long. Few examples of such blogs can be found below:

```{r blogsShortAnalysis, echo = F}
a <- data.blogs.all.nchar <= shortBlogs.maxNoOfChar
head(data.blogs.all[a], 10)
```

Because of the limited number of such blogs and the "irrelevance" of their content , it has been decided to remove them from the __blogs corpora__.

```{r blogsShortRemoval, echo = F}
#Removing such short blogss
data.blogs.all <- data.blogs.all[data.blogs.all.nchar > shortBlogs.maxNoOfChar]
data.blogs.all.nchar <- nchar(data.blogs.all)

#blogs.df <- data.frame(text = data.blogs.all, nchar = data.blogs.all.nchar)

data1.sources <- c("twitters", "news", "blogs")
data1.noOfLines <- c(length(data.twitter.all), length(data.news.all), length(data.blogs.all))
data1.maxNoOfChars <- c(max(data.twitter.all.nchar), max(data.news.all.nchar), max(data.blogs.all.nchar))
data1.minNoOfChars <- c(min(data.twitter.all.nchar), min(data.news.all.nchar), min(data.blogs.all.nchar))

data1.info.df <- data.frame(sources = data1.sources, 
                           noOfLines = data1.noOfLines, 
                           maxNoOfChar = data1.maxNoOfChars,
                           minNoOfChar = data1.minNoOfChars)
```

`r kable(data1.info.df)`

## Sampling of the Corpora

For this analysis it is not needed use all of the data. Often relatively few randomly selected rows or chunks need to be included to get an accurate approximation to results that would be obtained using all the data. A biased coin" has been used to select the tweets, news and blogs to be included in the analysis based on teh following percentages

* 5% of the tweets
* 10% of the news
* 10% of the blogs

```{r dataReductionForExploration, collapse=T}
set.seed(19711004)
coin.biased.outcome <- rbinom(length(data.twitter.all), 1, 0.05)
table(coin.biased.outcome)
data.twitter.sample <- data.twitter.all[coin.biased.outcome == 1]

set.seed(19711004)
coin.biased.outcome <- rbinom(length(data.news.all), 1, 0.10)
table(coin.biased.outcome)
data.news.sample <- data.news.all[coin.biased.outcome == 1]

set.seed(19711004)
coin.biased.outcome <- rbinom(length(data.blogs.all), 1, 0.10)
table(coin.biased.outcome)
data.blogs.sample <- data.blogs.all[coin.biased.outcome == 1]

save(data.twitter.sample, data.news.sample, data.blogs.sample, file = "./../data/processed/datasets_sample.Rdata")
```

```{r visualizeData, eval=F}
load("./../data/processed/datasets_sample.Rdata")

require(tm)
require(wordcloud)
require(RWeka)
require(ggplot2)


removePunctuations.exceptApostrophe <- function(texts){
    gsub(pattern = "[^'[:^punct:]]", replacement = " ", x = texts, perl = T)
}

test <- "I like %$@to*&, chew;: gum, but don't like|}{[] bubble@#^)( gum!?"
test.expected <- "I like    to    chew   gum  but don't like      bubble      gum  "
test.expected == removePunctuations.exceptApostrophe(texts = test)

tdm.generate <- function(x){
  corpus <- Corpus(VectorSource(x))
  corpus <- tm_map(corpus, content_transformer(tolower))
  #corpus <- tm_map(corpus, removeWords, stopwords.badWords)
  corpus <- tm_map(corpus, removeNumbers) 
  corpus <- tm_map(corpus, content_transformer(removePunctuations.exceptApostrophe))
  corpus <- tm_map(corpus, stripWhitespace)
  tdm <- TermDocumentMatrix(corpus)
  tdm
}


tdm.1g <- tdm.generate(data.twitter.sample[1:50000])
tdm.1g

findFreqTerms(tdm.1g,lowfreq = 100)
findFreqTerms(tdm.1g,lowfreq = 300)
findFreqTerms(tdm.1g,lowfreq = 500)

a <- findFreqTerms(tdm.1g,lowfreq = 500)
tdm.1g.l <- tdm.1g[a,]
tdm.1g.l
tdm.1g.l.asMatrix <- as.matrix(tdm.1g.l)

frequentTerms<-findFreqTerms(tdm.1g,lowfreq = 500)
highFreqTerms <- findFreqTerms(tdm.1g, lowfreq = 1000)

# calculate frequency of each term
term.freq <- rowSums(tdm.1g.l.asMatrix)

# picking only a subset
subsetterm.freq <- subset(term.freq, term.freq >= 700)

# create data frame from subset of terms
frequentTermsSubsetDF <- data.frame(term = names(subsetterm.freq), freq = subsetterm.freq)

# create data frame with all terms
frequentTermsDF <- data.frame(term = names(term.freq), freq = term.freq)

# sort by subset DataFrame frequency
frequentTermsSubsetDF <- frequentTermsSubsetDF[with(frequentTermsSubsetDF, order(-frequentTermsSubsetDF$freq)), ]

# sort by complete DataFrame frequency
frequentTermsDF <- frequentTermsDF[with(frequentTermsDF, order(-frequentTermsDF$freq)), ]

# words by frequency from subset data frame
ggplot(frequentTermsSubsetDF, aes(x = reorder(term,freq), y = freq)) + geom_bar(stat = "identity") +xlab("Terms") + ylab("Frequency") + coord_flip()
wordcloud(words = frequentTermsSubsetDF$term,freq = frequentTermsSubsetDF$freq)


tdm.generate.ngrams <- function(x, ng){
  corpus <- Corpus(VectorSource(x))
  corpus <- tm_map(corpus, content_transformer(tolower))
  #corpus <- tm_map(corpus, removeWords, stopwords.badWords)
  corpus <- tm_map(corpus, removeNumbers) 
  corpus <- tm_map(corpus, content_transformer(removePunctuations.exceptApostrophe))
  corpus <- tm_map(corpus, stripWhitespace)
  # MAC OS Manadtory if not using doMC library
  #options(mc.cores=1) 
  ngramTokenizer <- function(y) NGramTokenizer(y, Weka_control(min = ng, max = ng, delimiters = " \\r\\n\\t.,;:\"()?!")) 
  # create n-grams
  tdm <- TermDocumentMatrix(corpus, control = list(tokenize = ngramTokenizer)) # create tdm from n-grams
  tdm
}

tdm.2g <- tdm.generate.ngrams(x = data.twitter.sample[1:50000],ng = 2)
tdm.2g

findFreqTerms(tdm.2g,lowfreq = 100)
findFreqTerms(tdm.2g,lowfreq = 200)
findFreqTerms(tdm.2g,lowfreq = 300)
findFreqTerms(tdm.2g,lowfreq = 500)

b <- findFreqTerms(tdm.2g,lowfreq = 300)
tdm.2g.l <- tdm.2g[b,]
tdm.2g.l
tdm.2g.l.asMatrix <- as.matrix(tdm.2g.l)

term.2g.freq <- rowSums(tdm.2g.l.asMatrix)
frequentTermsDF.2g <- data.frame(term = names(term.2g.freq), freq = term.2g.freq)

frequentTermsDF.2g <- frequentTermsDF.2g[with(frequentTermsDF.2g, order(-frequentTermsDF.2g$freq)), ]

# words by frequency from subset data frame
ggplot(frequentTermsDF.2g, aes(x = reorder(term,freq), y = freq)) + geom_bar(stat = "identity") +xlab("Terms") + ylab("Frequency") + coord_flip()
wordcloud(words = frequentTermsDF.2g$term,freq = frequentTermsDF.2g$freq)


tdm.3g <- tdm.generate.ngrams(x = data.twitter.sample[1:50000],ng = 3)
tdm.3g

findFreqTerms(tdm.3g,lowfreq = 30)
findFreqTerms(tdm.3g,lowfreq = 40)
findFreqTerms(tdm.3g,lowfreq = 50)
findFreqTerms(tdm.3g,lowfreq = 60)

c <- findFreqTerms(tdm.3g,lowfreq = 50)
tdm.3g.l <- tdm.3g[c,]
tdm.3g.l
tdm.3g.l.asMatrix <- as.matrix(tdm.3g.l)

term.3g.freq <- rowSums(tdm.3g.l.asMatrix)
frequentTermsDF.3g <- data.frame(term = names(term.3g.freq), freq = term.3g.freq)

frequentTermsDF.3g <- frequentTermsDF.3g[with(frequentTermsDF.3g, order(-frequentTermsDF.3g$freq)), ]

# words by frequency from subset data frame
ggplot(frequentTermsDF.3g, aes(x = reorder(term,freq), y = freq)) + geom_bar(stat = "identity") +xlab("Terms") + ylab("Frequency") + coord_flip()
wordcloud(words = frequentTermsDF.3g$term,freq = frequentTermsDF.3g$freq)
```

